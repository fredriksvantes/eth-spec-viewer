<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ethereum Consensus Specifications</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 100%;
      margin: 0;
      padding: 20px;
    }

    .phase-group {
      border: 2px solid #999;
      border-radius: 5px;
      margin-bottom: 20px;
      padding: 10px;
      background: #fafafa;
    }
    .phase-group h2 {
      margin-top: 0;
      margin-bottom: 10px;
      background: #ddd;
      padding: 8px;
      border-radius: 4px;
    }

    .preset-group {
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      overflow: hidden;
    }
    details {
      margin: 0;
      padding: 0;
    }
    summary {
      cursor: pointer;
      list-style: none;
      padding: 10px;
      background: #eee;
      font-weight: bold;
      border-bottom: 1px solid #ccc;
      outline: none; /* remove outline on click */
    }
    summary::-webkit-details-marker {
      /* Hide default arrow in Chrome/Safari */
      display: none;
    }
    .summary-icon::before {
      content: "▶ ";
    }
    details[open] .summary-icon::before {
      content: "▼ ";
    }
    .collapsed-header {
      display: inline-block;
      vertical-align: middle;
      margin-left: 5px;
    }
    .expanded-content {
      padding: 10px;
      background: #f9f9f9;
    }

    .badge {
      display: inline-block;
      color: #fff;
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 0.85em;
      margin-left: 8px;
      vertical-align: middle;
    }

    .fork-table {
      width: 100%;
      max-width: 800px;
      border-collapse: collapse;
      margin-top: 10px;
      border: 1px solid #bbb;
    }
    .fork-table th,
    .fork-table td {
      border: 1px solid #bbb;
      padding: 5px;
      text-align: left;
    }
    .fork-table th {
      background: #ddd;
    }
  </style>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</head>
<body>
  <h1>Ethereum Consensus Specifications</h1>

  <details>
    <summary>
      <span class="summary-icon"></span>
      Preset Variables
    </summary>
    <div id="preset-container"></div>
  </details>

  <details>
    <summary>
      <span class="summary-icon"></span>
      Configuration Variables
    </summary>
    <div id="config-container"></div>
  </details>

  <details>
    <summary>
      <span class="summary-icon"></span>
      Functions
    </summary>
    <div id="function-container"></div>
  </details>

  <script>
    let jsonData = {};

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Shared Helper Functions
    ///////////////////////////////////////////////////////////////////////////////////////////////

    function getForkColor(forkName) {
      const colors = {
        PHASE0:    "#6c757d", // gray
        ALTAIR:    "#28a745", // green
        BELLATRIX: "#007bff", // blue
        CAPELLA:   "#6f42c1", // purple
        DENEB:     "#e83e8c", // pink
        ELECTRA:   "#ffc107", // yellow
        FULU:      "#c1c107", // greenish yellow
      };
      const up = forkName.toUpperCase();
      return colors[up] || "#17a2b8"; // fallback = teal
    }

    function phaseIncluded(phaseName) {
      return !phaseName.toUpperCase().startsWith("EIP")
        && phaseName.toUpperCase() != "WHISK";
    }

    function getIncludedPhases(presetData) {
      if (!presetData) return [];
      return Object.keys(presetData).filter(phaseIncluded);
    }

    function parseForkName(varName, knownForkNames) {
      const varNameUpper = varName.toUpperCase();
      for (const forkNameUpper of knownForkNames) {
        const suffix = "_" + forkNameUpper;
        if (varNameUpper.endsWith(suffix)) {
          const base = varName.slice(0, varName.length - suffix.length);
          return { base, fork: forkNameUpper };
        }
      }
      return { base: varName, fork: null };
    }

    function parseValue(fields) {
      return {
        type: fields[0] ?? "Unknown",
        value: fields[1] ?? "N/A",
      };
    }

    function forkGroupCompareAscending(a, b) {
      if (a === "PHASE0" && b !== "PHASE0") return -1;
      if (b === "PHASE0" && a !== "PHASE0") return 1;
      return a.localeCompare(b);
    }

    function forkGroupCompareDescending(a, b) {
      if (a === "PHASE0" && b !== "PHASE0") return 1;
      if (b === "PHASE0" && a !== "PHASE0") return -1;
      return b.localeCompare(a);
    }

    // helper: final value for (fk) from base + forks
    function getForkValue(fk, baseVal, forkArr) {
      if (!baseVal) return { value: undefined, type: "" };
      if (fk === baseVal.introducingFork) {
        return { value: baseVal.value, type: baseVal.type };
      }
      if (!forkArr) return { value: undefined, type: "" };

      let foundVal = null;
      let foundType = null;
      forkArr.forEach((f) => {
        if (f.fork === fk) {
          foundVal = f.value;
          foundType = f.type;
        }
      });
      if (foundVal === null) {
        return { value: undefined, type: "" };
      }
      return { value: foundVal, type: foundType };
    }

    function buildSummary(name, mBase, mForks, displayTypeAndValue = true) {
      if (!mBase && (!mForks || !mForks.length)) {
        return `${name} = (no mainnet data)`;
      }

      // Collect all fork names (base + forks)
      const forkNames = new Set();
      if (mBase) forkNames.add(mBase.introducingFork);
      if (mForks) {
        mForks.forEach((f) => forkNames.add(f.fork));
      }

      // Sort forks in the desired order (PHASE0 first, then reverse alphabetical)
      const sortedForks = Array.from(forkNames).sort(forkGroupCompareDescending);

      // Generate badges for all forks
      const badges = sortedForks
        .map((fork) => {
          const color = getForkColor(fork);
          return `<span class="badge" style="background-color: ${color}">${fork}</span>`;
        })
        .join(" ");

      let lastVal = mBase?.value || "N/A";
      let lastType = mBase?.type || "";

      if (mForks && mForks.length > 0) {
        // Get value from the most recent fork
        const newest = mForks[mForks.length - 1];
        lastVal = newest.value;
        lastType = newest.type || lastType;
      }

      if (displayTypeAndValue) {
        const displayType = lastType && lastType !== "Unknown" ? `: ${lastType} = ` : ` = `;
        return `${name}${displayType}${lastVal} ${badges}`;
      } else {
        return `${name} ${badges}`;
      }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Render Variables (Preset & Configuration)
    ///////////////////////////////////////////////////////////////////////////////////////////////

    function buildRows(mBase, mForks, nBase, nForks) {
      const allForks = new Set();
      if (mBase) allForks.add(mBase.introducingFork);
      (mForks || []).forEach((f) => allForks.add(f.fork));

      if (nBase) allForks.add(nBase.introducingFork);
      (nForks || []).forEach((f) => allForks.add(f.fork));

      let forkArray = Array.from(allForks);
      forkArray.sort(forkGroupCompareDescending);

      return forkArray.map((fk) => {
        const mainnet = getForkValue(fk, mBase, mForks);
        const minimal = getForkValue(fk, nBase, nForks);

        return {
          fork: fk,
          type: mainnet.type,
          mainnetValue: mainnet.value,
          minimalValue: minimal.value,
        };
      });
    }

    function buildTable(rows) {
      if (!rows.length) {
        return `<p style="color: grey;">No data</p>`;
      }
      const rowHTML = rows.map((r) => `
        <tr>
          <td>${r.fork}</td>
          <td>${r.type}</td>
          <td>${r.mainnetValue}</td>
          <td>${r.minimalValue}</td>
        </tr>
      `).join("");

      return `
        <table class="fork-table">
          <thead>
            <tr>
              <th>Fork</th>
              <th>Type</th>
              <th>Mainnet</th>
              <th>Minimal</th>
            </tr>
          </thead>
          <tbody>${rowHTML}</tbody>
        </table>
      `;
    }

    function renderVariable(baseName, mBase, mForks, nBase, nForks) {
      const rows = buildRows(mBase, mForks, nBase, nForks);
      const table = buildTable(rows);
      const summaryText = buildSummary(baseName, mBase, mForks);

      const details = document.createElement("details");
      details.className = "preset-group";

      const summary = document.createElement("summary");
      summary.innerHTML = `
        <span class="summary-icon"></span>
        <span class="collapsed-header">${summaryText}</span>
      `;
      details.appendChild(summary);

      const content = document.createElement("div");
      content.className = "expanded-content";
      content.innerHTML = table;
      details.appendChild(content);

      return details;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Render Code (Functions)
    ///////////////////////////////////////////////////////////////////////////////////////////////

    function renderCode(baseName, mBase, mForks) {
      const summaryText = buildSummary(baseName, mBase, mForks, displayTypeAndValue=false);

      const details = document.createElement("details");
      details.className = "preset-group";

      const summary = document.createElement("summary");
      summary.innerHTML = `
        <span class="summary-icon"></span>
        <span class="collapsed-header">${summaryText}</span>
      `;
      details.appendChild(summary);

      const content = document.createElement("div");
      content.className = "expanded-content";

      for (const {fork, value} of [...mForks].reverse()) {
        const section = document.createElement('div');
        section.innerHTML = `
          <details class="preset-group">
            <summary>
              <span class="summary-icon"></span>
              <span class="badge" style="background-color: ${getForkColor(fork)}">${fork}</span>
            </summary>
            <pre class="line-numbers"><code class="language-python">${value}</code></pre>
          </details>
        `;
        content.appendChild(section);
      }

      const section = document.createElement('div');
      section.innerHTML = `
        <details class="preset-group">
          <summary>
            <span class="summary-icon"></span>
            <span class="badge" style="background-color: ${getForkColor(mBase.introducingFork)}">${mBase.introducingFork}</span>
          </summary>
          <pre class="line-numbers"><code class="language-python">${mBase.value}</code></pre>
        </details>
      `;
      content.appendChild(section);

      details.appendChild(content);

      return details;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Collect Preset Variables
    ///////////////////////////////////////////////////////////////////////////////////////////////

    function collectPresets(presetData) {
      const baseVars = {};
      const forkVars = {};
      const lastForkValue = {};

      if (!presetData) return { baseVars, forkVars };

      const includedPhases = getIncludedPhases(presetData);
      const knownForkNames = includedPhases.map((p) => p.toUpperCase());

      includedPhases.forEach((phaseName) => {
        const phaseObj = presetData[phaseName];
        if (!phaseObj?.preset_vars) return;

        Object.keys(phaseObj.preset_vars).forEach((varName) => {
          const { base, fork } = parseForkName(varName, knownForkNames);
          const parsedVal = parseValue(phaseObj.preset_vars[varName]);

          // ensure a base
          if (!baseVars[base]) {
            baseVars[base] = {
              type: parsedVal.type,
              value: parsedVal.value,
              introducingFork: (fork || phaseName).toUpperCase(),
            };
          }

          if (!fork) {
            // update base
            baseVars[base].type = parsedVal.type;
            baseVars[base].value = parsedVal.value;
            return;
          }

          // it's a fork update
          if (!forkVars[base]) {
            forkVars[base] = [];
          }
          if (!lastForkValue[base]) {
            lastForkValue[base] = {};
          }
          if (lastForkValue[base][fork] === undefined) {
            lastForkValue[base][fork] = baseVars[base].value;
          }
          const prevVal = lastForkValue[base][fork];
          if (parsedVal.value !== prevVal) {
            forkVars[base].push({
              fork,
              value: parsedVal.value,
              type: parsedVal.type,
            });
            lastForkValue[base][fork] = parsedVal.value;
          }
        });
      });

      return { baseVars, forkVars };
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Collect Configuration Variables
    ///////////////////////////////////////////////////////////////////////////////////////////////

    function collectConfigs(configData) {
      const baseVars = {};
      const forkVars = {};
      const lastForkValue = {};

      if (!configData) return { baseVars, forkVars };

      const includedPhases = getIncludedPhases(configData);
      const knownForkNames = includedPhases.map((p) => p.toUpperCase());

      includedPhases.forEach((phaseName) => {
        const phaseObj = configData[phaseName];
        if (!phaseObj?.config_vars) return;

        Object.keys(phaseObj.config_vars).forEach((varName) => {
          const { base, fork } = parseForkName(varName, knownForkNames);
          const parsedVal = parseValue(phaseObj.config_vars[varName]);

          // ensure a base
          if (!baseVars[base]) {
            baseVars[base] = {
              type: parsedVal.type,
              value: parsedVal.value,
              introducingFork: (fork || phaseName).toUpperCase(),
            };
          }

          if (!fork) {
            // update base
            baseVars[base].type = parsedVal.type;
            baseVars[base].value = parsedVal.value;
            return;
          }

          // it's a fork update
          if (!forkVars[base]) {
            forkVars[base] = [];
          }
          if (!lastForkValue[base]) {
            lastForkValue[base] = {};
          }
          if (lastForkValue[base][fork] === undefined) {
            lastForkValue[base][fork] = baseVars[base].value;
          }
          const prevVal = lastForkValue[base][fork];
          if (parsedVal.value !== prevVal) {
            forkVars[base].push({
              fork,
              value: parsedVal.value,
              type: parsedVal.type,
            });
            lastForkValue[base][fork] = parsedVal.value;
          }
        });
      });

      return { baseVars, forkVars };
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Collect Functions
    ///////////////////////////////////////////////////////////////////////////////////////////////

    function collectFunctions(functionData) {
      const baseVars = {};
      const forkVars = {};
      const lastForkValue = {};

      if (!functionData) return { baseVars, forkVars };

      const includedPhases = getIncludedPhases(functionData);
      const knownForkNames = includedPhases.map((p) => p.toUpperCase());

      includedPhases.forEach((phaseName) => {
        const phaseObj = functionData[phaseName];
        if (!phaseObj?.functions) return;

        Object.keys(phaseObj.functions).forEach((fnName) => {
          const fnBody = phaseObj.functions[fnName];
          const fork = phaseName.toUpperCase();

          if (!baseVars[fnName]) {
            baseVars[fnName] = {
              value: fnBody,
              introducingFork: fork,
            };
            return;
          }

          if (!forkVars[fnName]) {
            forkVars[fnName] = [];
          }
          if (lastForkValue[fnName] === undefined) {
            lastForkValue[fnName] = baseVars[fnName].value;
          }

          const prevVal = lastForkValue[fnName];
          if (fnBody !== prevVal) {
            forkVars[fnName].push({
              fork,
              value: fnBody,
            });
            lastForkValue[fnName] = fnBody;
          }
        });
      });

      return { baseVars, forkVars };
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Render Everything
    ///////////////////////////////////////////////////////////////////////////////////////////////

    async function loadData() {
      try {
        const resp = await fetch("pyspec.json");
        if (!resp.ok) throw new Error(`HTTP error: ${resp.status}`);
        jsonData = await resp.json();

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Preset Variables
        ///////////////////////////////////////////////////////////////////////////////////////////

        const mainnetPresets = collectPresets(jsonData.mainnet);
        const minimalPresets = collectPresets(jsonData.minimal);

        const allPresetVars = new Set([
          ...Object.keys(mainnetPresets.baseVars),
          ...Object.keys(minimalPresets.baseVars),
        ]);

        const presetGroups = {};
        allPresetVars.forEach((baseName) => {
          const mVal = mainnetPresets.baseVars[baseName];
          const nVal = minimalPresets.baseVars[baseName];
          const grp = mVal.introducingFork;
          if (!presetGroups[grp]) presetGroups[grp] = [];
          presetGroups[grp].push(baseName);
        });

        const presetGroupKeys = Object.keys(presetGroups).sort(forkGroupCompareAscending);

        const presetVarsContainer = document.getElementById("preset-container");
        presetVarsContainer.innerHTML = "";

        presetGroupKeys.forEach((groupName) => {
          const groupDiv = document.createElement("div");
          groupDiv.className = "phase-group";
          groupDiv.innerHTML = `<h2>${groupName}</h2>`;

          const varNames = presetGroups[groupName];
          varNames.sort();
          varNames.forEach((vName) => {
            const row = renderVariable(
              vName,
              mainnetPresets.baseVars[vName],
              mainnetPresets.forkVars[vName] || [],
              minimalPresets.baseVars[vName],
              minimalPresets.forkVars[vName] || []
            );
            groupDiv.appendChild(row);
          });

          presetVarsContainer.appendChild(groupDiv);
        });

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Configuration Variables
        ///////////////////////////////////////////////////////////////////////////////////////////

        const mainnetConfigs = collectConfigs(jsonData.mainnet);
        const minimalConfigs = collectConfigs(jsonData.minimal);

        const allConfigVars = new Set([
          ...Object.keys(mainnetConfigs.baseVars),
          ...Object.keys(minimalConfigs.baseVars),
        ]);

        const configGroups = {};
        allConfigVars.forEach((baseName) => {
          const mVal = mainnetConfigs.baseVars[baseName];
          const nVal = minimalConfigs.baseVars[baseName];
          const grp = mVal.introducingFork;
          if (!configGroups[grp]) configGroups[grp] = [];
          configGroups[grp].push(baseName);
        });

        const configGroupKeys = Object.keys(configGroups).sort(forkGroupCompareAscending);

        const configVarsContainer = document.getElementById("config-container");
        configVarsContainer.innerHTML = "";

        configGroupKeys.forEach((groupName) => {
          const groupDiv = document.createElement("div");
          groupDiv.className = "phase-group";
          groupDiv.innerHTML = `<h2>${groupName}</h2>`;

          const varNames = configGroups[groupName];
          varNames.sort();
          varNames.forEach((vName) => {
            const row = renderVariable(
              vName,
              mainnetConfigs.baseVars[vName],
              mainnetConfigs.forkVars[vName] || [],
              minimalConfigs.baseVars[vName],
              minimalConfigs.forkVars[vName] || []
            );
            groupDiv.appendChild(row);
          });

          configVarsContainer.appendChild(groupDiv);
        });

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Functions
        ///////////////////////////////////////////////////////////////////////////////////////////

        const functions = collectFunctions(jsonData.mainnet);

        const allFunctions = new Set([
          ...Object.keys(functions.baseVars),
        ]);

        const functionGroups = {};
        allFunctions.forEach((baseName) => {
          const mVal = functions.baseVars[baseName];
          const grp = mVal.introducingFork;
          if (!functionGroups[grp]) functionGroups[grp] = [];
          functionGroups[grp].push(baseName);
        });

        const functionGroupKeys = Object.keys(functionGroups).sort(forkGroupCompareAscending);

        const functionsContainer = document.getElementById("function-container");
        functionsContainer.innerHTML = "";

        functionGroupKeys.forEach((groupName) => {
          const groupDiv = document.createElement("div");
          groupDiv.className = "phase-group";
          groupDiv.innerHTML = `<h2>${groupName}</h2>`;

          const fnNames = functionGroups[groupName];
          fnNames.sort();
          fnNames.forEach((fnName) => {
            const row = renderCode(
              fnName,
              functions.baseVars[fnName],
              functions.forkVars[fnName] || [],
            );
            groupDiv.appendChild(row);
          });

          functionsContainer.appendChild(groupDiv);
        });
      } catch (err) {
        console.error("Error loading data:", err);
      }

      Prism.highlightAll();
    }

    loadData();
  </script>
</body>
</html>